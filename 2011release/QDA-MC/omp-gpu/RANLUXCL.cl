#ifndef RANLUXCL_CL
#define RANLUXCL_CL

//#pragma OPENCL EXTENSION cl_amd_printf : enable

/**** RANLUXCL v1.2.0 ****************************************

 ***** DESCRIPTION ******************************************************************

Implements the RANLUX generator of Matrin Luscher, based on the Fortran 77
implementation by Fred James. This OpenCL code along with the C++ function
ranluxcl_initialization in ranluxcl.h is a complete implementation which should
perfectly replicate the numbers generated by the original fortran77 implementation.

 ***** USAGE ************************************************************************

To use, call ranluxcl_initialization in host code. It returns a pointer to a
cl_float4 array, and also returns the size of said array in bytes. This
array should be transferred to an OpenCL buffer. See comments in
ranluxcl.hpp for more details about the initialization.

Simple sample kernel that writes a pseudorandom float4 to global memory:

#include "ranluxcl.cl"
__kernel void Kernel_PRN(__global float4* RANLUXCLTab, __global float4* PRNs)
{
        //Downloading RANLUXCLTab. The state of RANLUXCL is stored in ranluxclstate.
        ranluxcl_state_t ranluxclstate;
        ranluxcl_download_seed(&ranluxclstate, RANLUXCLTab);

        float4 randomnr = ranluxcl(&ranluxclstate);

        PRNs[get_global_id(0)] = randomnr;

        //Uploading RANLUXCLTab
        ranluxcl_upload_seed(&ranluxclstate, RANLUXCLTab);
}

The ranluxcl_download_seed and ranluxcl_upload_seed functions assume that the
RANLUXCLTab in global memory has enough values for all the work-items, i.e. that
the numWorkitems variable passed to ranluxcl_initialization in host code corresponds
to the number of work-items in the current NDRange. If this is not the case the
behaviour is, as they say, "undefined".

There are a total of four functions meant to be called by other OpenCL code:

ranluxcl_download_seed(ranluxcl_state_t *ranluxclstate, __global float4 *RANLUXCLTab)
Run at the beginning of a kernel to download ranluxcl state data

ranluxcl_upload_seed(ranluxcl_state_t *ranluxclstate, __global float4 *RANLUXCLTab)
Run at the end of a kernel to upload state data

ranluxcl(ranluxcl_state_t *ranluxclstate)
Run to generate a float4

ranluxcl_synchronize(ranluxcl_state_t *ranluxclstate)
Run to synchronize execution in case different work-items have made a different
number of calls to ranluxcl. On SIMD machines this could lead to inefficient execution.
ranluxcl_synchronize allows us to make sure all generators are SIMD-friendly again. Not
needed if all work-items always call ranluxcl the same number of times.

ranluxcl_warmup(ranluxcl_state_t *ranluxclstate)
Run once before any values are generated using ranluxcl(). This will ensure that
the parallel generators are not correlated. While you could just run this in any
kernel where ranluxcl is used, that would be wastefull. It is only necessary to
call ranluxcl_warmup once for each work-item to make sure there are no
correlations from the initialization procedure. For instance the following kernel
could be launched right after ranluxcl_initialization was called in host code:

#include "ranluxcl.cl"
__kernel void Kernel_RANLUXCL_Warmup(__global float4* RANLUXCLTab)
{
        //Downloading RANLUXCLTab. The state of RANLUXCL is stored in ranluxclstate.
        ranluxcl_state_t ranluxclstate;
        ranluxcl_download_seed(&ranluxclstate, RANLUXCLTab);

        ranluxcl_warmup(&ranluxclstate);

        //Uploading RANLUXCLTab
        ranluxcl_upload_seed(&ranluxclstate, RANLUXCLTab);
}

 ***** PERFORMANCE ******************************************************************

For luxury setting 3, performance on AMD cypress should be ~7*10^9 pseudorandom
values per second, when not downloading values to host memory (i.e. the values are
just generated, but not used for anything in particular).

 ***** IMPLEMENTATION DETAILS *******************************************************

There are two slightly different approaches combined in this file, namely planar
and planar shift. If RANLUXCL_NSKIP is set and is a multiple of 24 the planar scheme
is recovered through preprocessor directives (i.e. the unneeded parts of the
planar shift scheme are not included). If RANLUXCL_NSKIP is not set, or it is not a
multiple of 24 the planar shift scheme is used.

"Planar" refers to the fact that the algorithm is unrolled, i.e. all indexing
into the seeds is explicit. For this reason it becomes most convenient to always
discard some multiple of 24 values, i.e. the p-value should be some multiple of 24.
The idea for this approach comes from:

Vadim Demchik, Pseudo-random number generators for Monte Carlo simulations on
Graphics Processing Units, arXiv:1003.1898v1 [hep-lat]

In the planar shift scheme it is however possible to have p a multiple of 4 instead,
which allows us to avoid any resonances that might be present when p is a
multiple of the seeds table size. It also allows us to choose a p-value
corresponding to what Martin L�scher chose for his v3 version of RANLUX for our
luxury setting 4.

The planar shift algorithm is recommended (which is what is used by the default
luxury values 0 through 4 in ranluxcl_initialization), but there is a chance that
the simpler planar approach will be significantly faster on some architectures
since it includes fewer if tests and drops a switch. On AMD Cypress the
performance difference is about 10%. To use the planar approach RANLUXCL_NSKIP
must be defined in the kernel code to be the same as the nskip variable returned
by ranluxcl_initialization. If nskip is a multiple of 24 the planar scheme is
then recovered.

Note that the in24 variable is only used in planar shift, while stepnr takes the
place of in24 in the planar case.

 ***** CREDIT ***********************************************************************

I have been told by Fred James (the coder) that the original Fortran 77
implementation (which is the subject of the second paper below) is free to use and
share. Therefore I am using the MIT license (below). But most importantly please
always remember to give credit to the two articles by Martin Luscher and Fred James,
describing the generator and the fortran 77 implementation on which this
implementation is based, respectively:

Martin L�scher, A portable high-quality random number generator for lattice
field theory simulations, Computer Physics Communications 79 (1994) 100-110

F. James, RANLUX: A Fortran implementation of the high-quality pseudorandom
number generator of L�scher, Computer Physics Communications 79 (1994) 111-114

 ***** LICENSE **********************************************************************

Copyright (c) 2011 Ivar Ursin Nikolaisen

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 ***************************************************************************************/

typedef struct {
    float4 s01to04;
    float4 s05to08;
    float4 s09to12;
    float4 s13to16;
    float4 s17to20;
    float4 s21to24;
    float4 carryin24stepnrnskip;
} ranluxcl_state_t;

#define RANLUXCL_TWOM24 0.000000059604644775f
#define RANLUXCL_TWOM12 0.000244140625f

//Check that nskip is a permissible value if it's defined
#ifdef RANLUXCL_NSKIP
#if RANLUXCL_NSKIP % 4 != 0
#error nskip must be divisible by 4!
#endif
#if RANLUXCL_NSKIP < 24 && RANLUXCL_NSKIP != 0
#error nskip must be either 0 or >= 24!
#endif
#if RANLUXCL_NSKIP < 0
#error nskip is negative!
#endif

//Check if planar scheme is recovered
#if RANLUXCL_NSKIP % 24 == 0
#define RANLUXCL_PLANAR
#endif

//Check if we will skip at all
#if RANLUXCL_NSKIP == 0
#define RANLUXCL_NOSKIP
#endif

#endif //defined RANLUXCL_NSKIP

//Single-value global size and id
#define RANLUXCL_NUMWORKITEMS (get_global_size(0) * get_global_size(1) * get_global_size(2))
#define RANLUXCL_MYID (get_global_id(0) + get_global_id(1) * get_global_size(0) + get_global_id(2) * get_global_size(0) * get_global_size(1))

void ranluxcl_download_seed(ranluxcl_state_t *ranluxclstate, __global float4 *RANLUXCLTab) {
    (*ranluxclstate).s01to04 = RANLUXCLTab[RANLUXCL_MYID + 0 * RANLUXCL_NUMWORKITEMS];
    (*ranluxclstate).s05to08 = RANLUXCLTab[RANLUXCL_MYID + 1 * RANLUXCL_NUMWORKITEMS];
    (*ranluxclstate).s09to12 = RANLUXCLTab[RANLUXCL_MYID + 2 * RANLUXCL_NUMWORKITEMS];
    (*ranluxclstate).s13to16 = RANLUXCLTab[RANLUXCL_MYID + 3 * RANLUXCL_NUMWORKITEMS];
    (*ranluxclstate).s17to20 = RANLUXCLTab[RANLUXCL_MYID + 4 * RANLUXCL_NUMWORKITEMS];
    (*ranluxclstate).s21to24 = RANLUXCLTab[RANLUXCL_MYID + 5 * RANLUXCL_NUMWORKITEMS];
    (*ranluxclstate).carryin24stepnrnskip = RANLUXCLTab[RANLUXCL_MYID + 6 * RANLUXCL_NUMWORKITEMS];
}

void ranluxcl_upload_seed(ranluxcl_state_t *ranluxclstate, __global float4 *RANLUXCLTab) {
    RANLUXCLTab[RANLUXCL_MYID + 0 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s01to04;
    RANLUXCLTab[RANLUXCL_MYID + 1 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s05to08;
    RANLUXCLTab[RANLUXCL_MYID + 2 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s09to12;
    RANLUXCLTab[RANLUXCL_MYID + 3 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s13to16;
    RANLUXCLTab[RANLUXCL_MYID + 4 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s17to20;
    RANLUXCLTab[RANLUXCL_MYID + 5 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s21to24;
    RANLUXCLTab[RANLUXCL_MYID + 6 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).carryin24stepnrnskip;
}

#undef RANLUXCL_NUMWORKITEMS
#undef RANLUXCL_MYID

float ranluxcl_onestep_1(float4* vec1, float4* vec2, float4* carryin24stepnrnskip) {
    float uni, out;
    uni = (*vec1).y - (*vec2).w - (*carryin24stepnrnskip).x;
    if (uni < 0.0f) {
        uni += 1.0f;
        (*carryin24stepnrnskip).x = RANLUXCL_TWOM24;
    } else (*carryin24stepnrnskip).x = 0.0f;
    out = ((*vec2).w = uni);

    if (uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).y;

    if (out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
    return out;
}

float ranluxcl_onestep_2(float4* vec1, float4* vec2, float4* carryin24stepnrnskip) {
    float uni, out;
    uni = (*vec1).x - (*vec2).z - (*carryin24stepnrnskip).x;
    if (uni < 0.0f) {
        uni += 1.0f;
        (*carryin24stepnrnskip).x = RANLUXCL_TWOM24;
    } else (*carryin24stepnrnskip).x = 0.0f;
    out = ((*vec2).z = uni);

    if (uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).x;

    if (out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
    return out;
}

float ranluxcl_onestep_3(float4* vec1, float4* vec2, float4* carryin24stepnrnskip) {
    float uni, out;
    uni = (*vec1).w - (*vec2).y - (*carryin24stepnrnskip).x;
    if (uni < 0.0f) {
        uni += 1.0f;
        (*carryin24stepnrnskip).x = RANLUXCL_TWOM24;
    } else (*carryin24stepnrnskip).x = 0.0f;
    out = ((*vec2).y = uni);

    if (uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).w;

    if (out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
    return out;
}

float ranluxcl_onestep_4(float4* vec1, float4* vec2, float4* carryin24stepnrnskip) {
    float uni, out;
    uni = (*vec1).z - (*vec2).x - (*carryin24stepnrnskip).x;
    if (uni < 0.0f) {
        uni += 1.0f;
        (*carryin24stepnrnskip).x = RANLUXCL_TWOM24;
    } else (*carryin24stepnrnskip).x = 0.0f;
    out = ((*vec2).x = uni);

    if (uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).z;

    if (out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
    return out;
}

float4 ranluxcl(ranluxcl_state_t *ranluxclstate) {
    //ranluxcl returns a 4-component float vector where each component is uniformly distributed
    //between 0-1, end points not included.

    float4 out;

    if ((*ranluxclstate).carryin24stepnrnskip.z == 0.0f) {
        out.x = ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        out.y = ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        out.z = ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        out.w = ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        (*ranluxclstate).carryin24stepnrnskip.z += 4.0f;
    } else if ((*ranluxclstate).carryin24stepnrnskip.z == 4.0f) {
        out.x = ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        out.y = ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        out.z = ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        out.w = ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        (*ranluxclstate).carryin24stepnrnskip.z += 4.0f;
    } else if ((*ranluxclstate).carryin24stepnrnskip.z == 8.0f) {
        out.x = ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        out.y = ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        out.z = ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        out.w = ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        (*ranluxclstate).carryin24stepnrnskip.z += 4.0f;
    } else if ((*ranluxclstate).carryin24stepnrnskip.z == 12.0f) {
        out.x = ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        out.y = ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        out.z = ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        out.w = ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        (*ranluxclstate).carryin24stepnrnskip.z += 4.0f;
    } else if ((*ranluxclstate).carryin24stepnrnskip.z == 16.0f) {
        out.x = ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        out.y = ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        out.z = ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        out.w = ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        (*ranluxclstate).carryin24stepnrnskip.z += 4.0f;
    } else if ((*ranluxclstate).carryin24stepnrnskip.z == 20.0f) {
        out.x = ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        out.y = ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        out.z = ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        out.w = ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        (*ranluxclstate).carryin24stepnrnskip.z = 0.0f;

        //The below preprocessor directives are here to recover the simpler planar scheme when nskip is a multiple of 24.
        //For the most general planar shift approach, just ignore all #if's below.
#ifndef RANLUXCL_PLANAR
    }

    (*&((*ranluxclstate).carryin24stepnrnskip)).y += 4.0f;
    if ((*&((*ranluxclstate).carryin24stepnrnskip)).y == 24.0f) {
        (*&((*ranluxclstate).carryin24stepnrnskip)).y = 0.0f;
#endif //RANLUXCL_PLANAR

        int initialskips = (int) ((*ranluxclstate).carryin24stepnrnskip.z) ? (24 - (int) ((*ranluxclstate).carryin24stepnrnskip.z)) : 0;
        int bulkskips = (((int) ((*&((*ranluxclstate).carryin24stepnrnskip)).w) - initialskips) / 24) * 24;
        int remainingskips = (int) ((*&((*ranluxclstate).carryin24stepnrnskip)).w) - initialskips - bulkskips;

        //We know there won't be any initial skips in the planar scheme
#ifndef RANLUXCL_PLANAR
        //Do initial skips (lack of breaks in switch is intentional).
        switch (initialskips) {
            case(20):
                ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
            case(16):
                ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
            case(12):
                ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
            case(8):
                ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
            case(4):
                ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        }
#endif //RANLUXCL_PLANAR

        //Also check if we will ever need to skip at all
#ifndef RANLUXCL_NOSKIP
        for (int i = 0; i < bulkskips / 24; i++) {
            ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        }
#endif //RANLUXCL_NOSKIP

        //There also won't be any remaining skips in the planar scheme
#ifndef RANLUXCL_PLANAR
        //Do remaining skips
        if (remainingskips) {
            ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
            ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));

            if (remainingskips > 4) {
                ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
            }

            if (remainingskips > 8) {
                ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
            }

            if (remainingskips > 12) {
                ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
            }

            if (remainingskips > 16) {
                ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
                ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
            }
        }
#endif //RANLUXCL_PLANAR

        //Initial skips brought stepnr down to 0. The bulk skips did only full cycles.
        //Therefore stepnr is now equal to remainingskips.
        (*ranluxclstate).carryin24stepnrnskip.z = (float) remainingskips;
    }

    return out;
}

void ranluxcl_synchronize(ranluxcl_state_t *ranluxclstate) {
    //This function generates numbers so that the generator is at the beginning,
    //i.e. ready to generate 24 numbers before the next skipping sequence. This is
    //useful if different work-items have called ranluxcl a different number of times.
    //Since that would lead to out of sync execution it could be rather inefficient on
    //SIMD architectures like GPUs. This function thus allows us to resynchronize
    //execution across all work-items.

    //Do necessary number of calls to ranluxcl so that stepnr == 0 at the end.
    if ((*ranluxclstate).carryin24stepnrnskip.z == 4.0f)
        ranluxcl(ranluxclstate);
    if ((*ranluxclstate).carryin24stepnrnskip.z == 8.0f)
        ranluxcl(ranluxclstate);
    if ((*ranluxclstate).carryin24stepnrnskip.z == 12.0f)
        ranluxcl(ranluxclstate);
    if ((*ranluxclstate).carryin24stepnrnskip.z == 16.0f)
        ranluxcl(ranluxclstate);
    if ((*ranluxclstate).carryin24stepnrnskip.z == 20.0f)
        ranluxcl(ranluxclstate);
}

void ranluxcl_warmup(ranluxcl_state_t *ranluxclstate) {
    //This function "warms up" the generator, meaning it simply generates enough
    //values to ensure that the starting values are completely decorrelated.
    //It should be called once after ranluxcl_initialization in host code, after
    //the first call the sequences will stay uncorrelated.

    //16 is a "magic number". It is the number of times we must generate
    //a batch of 24 numbers to ensure complete decorrelation.
    for (int i = 0; i < 16; i++) {
        ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
        ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnrnskip));
    }

}

#undef RANLUXCL_TWOM24
#undef RANLUXCL_TWOM12
#endif //RANLUXCL_CL
