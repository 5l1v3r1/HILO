#pragma once
#ifndef RANLUXCL_HPP
#define RANLUXCL_HPP

/**** RANLUXCL v1.2.0 ****************************************

***** GENERAL USAGE ************************************************************

ranluxcl_initialization returns a pointer to an array of cl_float4, with size 
(i.e. number of bytes) as returned in the RANLUXCLTabSize variable. This is the
seeds table that must be transferred to the OpenCL device.

lux is the "luxury value" of the generator, and should be 0-4, where 0 is fastest
and 4 produces the best numbers. It can also be >=24, in which case it directly
sets the p-value of RANLUXCL (see details below).

ins is the seed which initializes RANLUXCL. It should be >= 0. If several devices
are used in parallel initializing each device's RANLUXTab with different ins
will ensure that all work-items are generating uncorrelated sequences. Just be
sure that maxWorkitems (described below) is set correctly.

numWorkitems is the number of generators to initialize, usually corresponding
to the number of work-items in the NDRange RANLUXCL will be used with.

maxWorkitems should reflect the maximum number of work-items that will be used
on any parallel instance of RANLUXCL. So for instance if we are launching 5120
work-items on GPU1 and 10240 work-items on GPU2, GPU1's RANLUXCLTab would be
generated by calling ranluxcl_intialization with numWorkitems = 5120 while 
GPU2's RANLUXCLTab would use numWorkitems = 10240. However maxWorkitems must 
be at least 10240 for both GPU1 and GPU2, and it must be set to the same value
for both.

nskip will return an integer which can (optionally) be defined in the kernel code
as RANLUXCL_NSKIP. If this is done the generator will be faster for luxury setting
0 and 1, or when the p-value is manually set to a multiple of 24 (more on this in
the implementation details below).

RANLUXCLTabSize returns the number of bytes allocated for the entire float4 seeds 
array, for instance for use when writing the seeds table to the device.

Please note that you MUST "warm up" the generators before using them for any
important computations. This is achieved by calling the ranluxcl_warmup
function in a kernel. See top comments in ranluxcl.cl for more information.

***** IMPLEMENTATION DETAILS *******************************************************

A linear congruential generator initializes the seeds array. They can be initialized 
in other ways as well, but this is the approach taken in the original code, which
has been extensively used and tested by other.

If lux is 0, 1, 2, 3 or 4, it is taken to be the luxury value, where 4 produces 
the best numbers. If lux is above 24, it is taken as the "p-value, where the 
number of values to throw away (nskip) is p - 24. For this OpenCL implementation, 
p must either be a multiple of 24 or 4, for the planar and planar shift variants 
respectively. If p is a multiple of 24 and RANLUXCL_NSKIP is set equal to nskip
in the kernel code, the planar scheme is recovered, which might be slightly faster.

This implementation is somewhat modified from the original fortran implementation 
by F. James. Because of the way the OpenCL code is optimized with 4-component 
32-bit float vectors, it is most convenient to always throw away some multiple 
of 24 values (i.e. p is always a multiple of 24). However, there might be some 
resonances if we always throw away a multiple of the seeds table size. Therefore 
the implementation is slightly more intricate where p can be a multiple of 4 
instead, at a cost to performance (only about 10% lower than the cleaner 24 values 
approach on AMD Cypress). These two approaches are termed planar and planar 
shift respectively.

Below the p-values for the original reference implementation are listed along with 
those of the planar shift implementation. Suggested values for the planar approach 
are also presented. When this function is called with lux 0-4, the planar shift 
values are used. To use the pure planar approach, set lux equal to the specific 
p-value.
	
Luxury setting (lux):                            0   1   2   3   4
Original fortran77 implementation by F. James:  24  48  97  223 389
Planar (suggested):                             24  48  120 240 408
Planar shift:                                   24  48  100 224 404

Note that levels 0 and 1 are the same as in the original implementation for both
planar and planar shift. Level 4 of planar shift where p=404 is the same as chosen 
for luxury level 1 by Martin Luescher for his v3 version of RANLUX. Therefore if 
it is considered important to only use "official" values, luxury settings 0, 1 or 
4 of planar shift should be used. It is however unlikely that the other values are 
bad, they just haven't been as extensively used and tested by others.

Variable names are generally the same as in the fortran77 implementation, however 
because of the way the generator is implemented, the i24 and j24 variables are 
no longer needed.

***** CREDIT ***********************************************************************

I have been told by Fred James (the coder) that the original Fortran 77 
implementation (which is the subject of the second paper below) is free to use and 
share. Therefore I am using the permissive MIT license (below). But most importantly 
please always remember to give credit to the two articles by Martin Luscher and 
Fred James, describing the generator and the fortran 77 implementation on which this 
implementation is based, respectively:

Martin L�scher, A portable high-quality random number generator for lattice 
field theory simulations, Computer Physics Communications 79 (1994) 100-110

F. James, RANLUX: A Fortran implementation of the high-quality pseudorandom 
number generator of L�scher, Computer Physics Communications 79 (1994) 111-114

***** LICENSE **********************************************************************

Copyright (c) 2011 Ivar Ursin Nikolaisen

Permission is hereby granted, free of charge, to any person obtaining a copy of this 
software and associated documentation files (the "Software"), to deal in the Software 
without restriction, including without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to the following 
conditions:

The above copyright notice and this permission notice shall be included in all copies 
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

***************************************************************************************/

//Use C++ headers
#ifdef __cplusplus
//This file only relies on the cl_float4, cl_int and cl_float datatypes from the OpenCL header.
#include <CL/cl.hpp>
#include <cstdlib>
#include <cstdarg>
#include <cstdio>

//Else assume C
#else
#include <CL/cl.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#endif //__cplusplus

#define numFloat4PerWorkitem 7

cl_float4 *ranluxcl_initialization(cl_int lux,
	                               cl_int ins,
	                               size_t numWorkitems,
	                               size_t maxWorkitems,
	                               cl_int *nskip,
	                               size_t *RANLUXCLTabSize)
{
#ifdef __cplusplus
	using namespace std;
#endif //__cplusplus

	const cl_int maxlev = 4, icons = 2147483563, itwo24 = 1<<24, pMustBeDivisibleBy = 4;
	const cl_int ndskip[5]={0,24,76,200,380};
	const cl_float twom24 = (cl_float)0.000000059604644775;
	cl_int scaledins, i;
	*RANLUXCLTabSize = sizeof(cl_float4) * numFloat4PerWorkitem * numWorkitems;

	cl_float4 *RANLUXCLTab = (cl_float4*)malloc(*RANLUXCLTabSize);
	if(RANLUXCLTab == NULL){
		fprintf(stderr, "Error in ranluxcl_initialization: failed to allocate memory for RANLUXCLTab. Exiting.\n");
		exit(1);
	}
	
	//Interpret the lux parameter correctly, either as luxury setting if 0, 1, 2, 3 or 4, or as p-value if
	//between 24 and 2000 (2000 and up is not likely to be intended by the programmer).
	if(lux < 0){
		fprintf(stderr, "Error in ranluxcl_initialization: illegal luxury level: %d, luxury cannot be negative. Exiting\n", lux);
		exit(1);
	}
	else if(lux <= maxlev)
		*nskip = ndskip[lux];
	else if(lux >= 24 && lux <= 2000 && !((lux - 24) % pMustBeDivisibleBy))
		*nskip = lux - 24;
	else{
		fprintf(stderr, "Error in ranluxcl_initialization: illegal luxury level: %d\n", lux);
		fprintf(stderr, "lux must be either 0-4, or lux >= 24. If lux >= 24 it is interpreted as the\n");
		fprintf(stderr, "p-value, which must be divisible by %d. Exiting.\n", pMustBeDivisibleBy);
		exit(1);
	}

	//Check that ins is positive
	if(ins < 0){
		fprintf(stderr, "Error in ranluxcl_initialization: ins is negative. Exiting.\n");
		exit(1);
	}

	//ins is scaled so that if the user makes another call somewhere else with ins + 1 there should be no overlap. Also adding one
	//allows us to use ins = 0.
	scaledins = ins * (cl_int)maxWorkitems + 1;

	//Check that we won't have seeds too high for the LCG used to initialize
	//cl_ulong highestRequestedSeed = (cl_ulong)(ins + 1) * (cl_ulong)maxWorkitems;
	cl_ulong highestRequestedSeed = (cl_ulong)scaledins + (cl_ulong)numWorkitems;
	if(highestRequestedSeed >= (cl_ulong)icons){
		fprintf(stderr, "Error in ranluxcl_initialization: combination of ins and maxWorkitems is too high. Exiting.\n");
		exit(1);
	}

	//Check that numWorkitems isn't larger than maxWorkitems (could mean the user is getting identical sequences without knowing it!)
	if(numWorkitems > maxWorkitems){
		fprintf(stderr, "Error in ranluxcl_initialization: numWorkitems is larger than maxWorkitems. Exiting.\n");
		exit(1);
	}

	size_t workitem;
	for(workitem = 0; workitem < numWorkitems; workitem++){
		cl_int jseed = scaledins + (cl_int)workitem;

		cl_int k;
		cl_int iseeds[24];
		cl_float seeds[numFloat4PerWorkitem * 4];

		for(i=0; i<24; i++){
			k = jseed / 53668;
			jseed = 40014 * (jseed-k*53668) - k * 12211;
			if (jseed < 0)
				jseed = jseed + icons;
 			iseeds[i] = jseed % itwo24;
		}
	
		for(i=0; i<24; i++)
			seeds[i] = iseeds[i] * twom24;

		seeds[24] = 0.0; //carry

		if(seeds[23] == 0.0)
			seeds[24] = twom24;

		seeds[25] = 0; //in24
		seeds[26] = 0; //stepnr
		seeds[27] = (cl_float)(*nskip); //nskip

		//Transfer seeds to RANLUXCLTab
		for(i = 0; i < numFloat4PerWorkitem; i++){
			RANLUXCLTab[workitem + numWorkitems * i].s[0] = seeds[4 * i + 0];
			RANLUXCLTab[workitem + numWorkitems * i].s[1] = seeds[4 * i + 1];
			RANLUXCLTab[workitem + numWorkitems * i].s[2] = seeds[4 * i + 2];
			RANLUXCLTab[workitem + numWorkitems * i].s[3] = seeds[4 * i + 3];
		}
	}

	return RANLUXCLTab;
}

#undef numFloat4PerWorkitem
#endif //RANLUXCL_HPP
